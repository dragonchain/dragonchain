global:
  environment:
    DRAGONCHAIN_NAME: "Arbitrary Name" # This can be anything
    REGISTRATION_TOKEN: "" # Use token from Dragon Net Registration (or arbitrary string if no Dragon Net)
    INTERNAL_ID: "" # Use id from Dragon Net registration (or arbitrary GUID if no Dragon Net)
    DRAGONCHAIN_ENDPOINT: "https://my-chain.api.company.org:443" # publicly accessible endpoint for this chain. MUST be able to be hit from the internet
    # If using a simple single node cluster like minikube, and the service values below are left as NodePort with port 30000, this would simply be 'http://public.ip.of.minikube.node:30000'
    LEVEL: "1" # Integer 1-5 as a string. Must match with Dragon Net registration if participating in Dragon Net
    STAGE: "prod"
    LOG_LEVEL: "debug"
    STORAGE_LOCATION: "/dragonchain" # Must match dragonchain.storage.mount from below
    BROADCAST: "true" # Set to 'false' if you want to disable Dragon Net support
    BROADCAST_INTERVAL: "2" # L5 ONLY! Number of hours between broadcasts to public chain

# -- isMinikube --
# When running on minikube this should be boolean true. otherwise boolean false.
# This is mainly used in the redis configuration to adjust the somaxconn to a value minikube should use.
# I.e:
# - name: net.core.somaxconn
#     value: "1024"
isMinikube: true

# -- service --
# This value helps determine how the dragonchain is exposed externally outside of the cluster
# If ingress is being used, then the service type should be ClusterIP
# If you want to expose the chain by hitting the kubernetes cluster directly, NodePort can be used with a unique port number
service:
  # If using ingress, this should be ClusterIP, if exposing via the cluster directly, (so it can be hit by the direct IP address of a node in the kubernetes cluster) this should be NodePort
  type: NodePort
  # Port is only needed if type is "NodePort", and exposing a chain without ingress. Must be 30000-32767 and unique per cluster
  port: 30000

# -- ingressEndpoint --
# Dragonchains will be communicating with eachother on the network using this cluster ingress.
# Every dragonchain will add an ingress record to your cluster, pointing to your chain's
# webserver with the following format: {dragonchainId}.{ingressEndpoint}
# Example: http://some-valid-dragonchain-id.api.my-company.org
ingressEndpoint: api.my-company.org

# -- faas --
# Every dragonchain will need to communicate with an OpenFaaS system to generate and run smart contracts.
# We recommend all values addressed within be located on a seperate Kubernetes cluster, but could
# theoretically live anywhere.
faas:
  # -- faas.gateway --
  #   This value should be the fully qualified url of the OpenFaas gateway you would like your chains to use.
  gateway: https://my-faas-gateway-url

  # -- faas.registry --
  #   This value should be the docker registry address at which your custom smart contract images will be stored.
  #   Library smart contracts will still use the dragonchain inc public smart contract registry regardless of this value.
  registry: mycompany.docker.io
  registry_username: MyUsername
  registry_password: MyPassword

# -- aws --
# This object should be set to null for on-prem deployments.
# At Dragonchain, Inc, our managed service platform requires that all dragonchains
# use AWS resources for storage to facilitate monitoring/maintanence/storage.
aws: null

# -- dragonchain --
# Dragonchain specific congifuration options live here.
dragonchain:
  # -- dragonchain.image --
  # Set the deployment configuration options for the dragonchain image.
  image:
    # -- dragonchain.image.pullPolicy --
    # In production we recommend "IfNotPresent". For development it is fine to use "Always"
    pullPolicy: IfNotPresent

    # -- dragonchain.image.registry --
    # This value should be registry at which your dragonchain image is stored.
    # e.g.: docker.io
    registry: docker.io

    # -- dragonchain.image.repository --
    # This value should be the name of the repository inside the registry which house your dragonchain image
    # e.g.: {registry}/{repository}:{stage}-{version}
    repository: dragonchain_core

    # -- dragonchain.image.version --
    # Version of your dragonchain. This value is used to interpolate the tag name.
    # e.g.: {registry}/{repository}:{stage}-{version}
    version: latest

    # -- dragonchain.image.stage --
    # This value is interpolated into the tag of the dragonchain image path.
    # Dragonchain inc uses this value to differentiate between dev and prod builds.
    # e.g.: {registry}/{repository}:{stage}-{version}
    stage: prod

  # -- dragonchain.database_type --
  # This configuration option should be null for any on-prem dragonchains.
  database_type: null

  # -- dragonchain.reporting_type --
  # This configuration option should be null for any on-prem dragonchains.
  reporting_type: null

  # -- dragonchain.storage --
  # The mount path of a persistent volume to be used by all dragonchain microservices.
  # This is where your actual blockchain data will be stored at-rest
  storage:
    mount: "/dragonchain"
    spec:
      # Switch storage class name to something usable within your cluster. Minikube accepts 'standard'
      storageClassName: standard
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 2Gi

es:
  image:
    repository: docker.elastic.co/elasticsearch/elasticsearch-oss
    tag: 6.6.0
    pullPolicy: "IfNotPresent"
  master:
    # -- es.master.persistence --
    # This is the storage spec that the elasticsearch uses to maintain state for
    # the indexes of a running dragonchain. Configure this as needed
    persistence:
      # Switch storage class name to something usable within your cluster. Minikube accepts 'standard'
      storageClass: standard
      accessMode: ReadWriteOnce
      size: 1Gi

redis:
  # -- redis.storage --
  # This is the storage spec that the persistent redis uses to maintain state for
  # a running dragonchain. Configure this as needed
  storage:
    spec:
      # Switch storage class name to something usable within your cluster. Minikube accepts 'standard'
      storageClassName: standard
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 1Gi
# For more information on kubernetes storage, view the docs: https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/
