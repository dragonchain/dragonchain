webserverLiveliness: true # Set this value to false if migrating from v3 to v4, and a lot of data needs to be re-indexed.
# Failure to set this to false for an upgrading chain means that the migrations may complete much slower as kubernetes continues to kill the webserver while re-indexing.

global:
  environment:
    DRAGONCHAIN_NAME: "ArbitraryName" # This can be anything
    REGISTRATION_TOKEN: "" # Use token from Dragon Net Registration (or arbitrary string if no Dragon Net)
    INTERNAL_ID: "" # Use id from Dragon Net registration (or arbitrary string if no Dragon Net)
    DRAGONCHAIN_ENDPOINT: "https://my-chain.api.company.org:443" # publicly accessible endpoint for this chain. MUST be able to be hit from the internet
    # If using a simple single node cluster like minikube, and the service values below are left as NodePort with port 30000, this would simply be 'http://public.ip.of.minikube.node:30000'
    # Remember to switch the protocol http:// or https:// depending on if you have enabled TLS support or not. (This can be any arbitrary string if no Dragon Net)
    LEVEL: "1" # Integer 1-5 as a string. Must match with Dragon Net registration if participating in Dragon Net
    TLS_SUPPORT: "" # Put 'true' here if you have created a TLS certificate and put into a tls kubernetes secret, otherwise leave empty
    LOG_LEVEL: "debug"
    BROADCAST: "true" # Set to 'false' if you want to disable Dragon Net support
    BROADCAST_INTERVAL: "2" # L5 ONLY! Number of hours between broadcasts to public chain

# -- isMinikube --
# When running on minikube this should be boolean true. otherwise boolean false.
# This is mainly used in the redis configuration to adjust the somaxconn to a value minikube should use.
# I.e:
# - name: net.core.somaxconn
#     value: "1024"
isMinikube: true

# -- service --
# This value helps determine how the dragonchain is exposed externally outside of the cluster
# If ingress is being used, then the service type should be ClusterIP
# If you want to expose the chain by hitting the kubernetes cluster directly, NodePort can be used with a unique port number
service:
  # If using ingress, this should be ClusterIP, if exposing via the cluster directly, (so it can be hit by the direct IP address of a node in the kubernetes cluster) this should be NodePort
  type: NodePort
  # Port is only needed if type is "NodePort", and exposing a chain without ingress. Must be 30000-32767 and unique per cluster
  port: 30000

# -- faas --
# Every dragonchain will need to communicate with an OpenFaaS system to generate and run smart contracts.
# We recommend all values addressed within be located on a seperate Kubernetes cluster, but could
# theoretically live anywhere.
faas:
  # -- faas.gateway --
  #   This value should be the fully qualified url of the OpenFaas gateway you would like your chains to use.
  gateway: https://my-faas-gateway-url

  # -- faas.mountFaasSecret --
  #   This value controls whether the secret for openfaas authorization should
  #   be mounted on the webserver for the get smart contract logs functionality
  mountFaasSecret: false

  # -- faas.registry --
  #   This value should be the docker registry address at which your custom smart contract images will be stored.
  #   Library smart contracts will still use the dragonchain inc public smart contract registry regardless of this value.
  registry: mycompany.docker.io
  registry_username: MyUsername
  registry_password: MyPassword

# -- dragonchain --
# Dragonchain specific congifuration options live here.
dragonchain:
  # -- dragonchain.image --
  # Set the deployment configuration options for the dragonchain image.
  image:
    # -- dragonchain.image.pullPolicy --
    # In production we recommend "IfNotPresent". For development it is fine to use "Always"
    # Just keep in mind that Always with a 'latest' tag means your node may receive unexpected updates
    pullPolicy: Always

    # -- dragonchain.image.registry --
    # This value should be registry at which your dragonchain image is stored.
    # e.g.: docker.io
    registry: docker.io

    # -- dragonchain.image.repository --
    # This value should be the name of the repository inside the registry which house your dragonchain image
    # e.g.: {registry}/{repository}:{version}
    repository: dragonchain/dragonchain_core

    # -- dragonchain.image.version --
    # Version of your dragonchain. This value is used to interpolate the tag name.
    # e.g.: {registry}/{repository}:{version}
    # Check here for available tags: https://hub.docker.com/r/dragonchain/dragonchain_core/tags
    # PLEASE USE A PINNED VERSION, AND NOT 'latest' FOR PRODUCTION DEPLOYMENTS
    version: latest

  # -- dragonchain.storage --
  # The mount path of a persistent volume to be used by all dragonchain microservices.
  # This is where your actual blockchain data will be stored at-rest
  storage:
    mount: "/dragonchain" # Don't change this value
    spec:
      # Switch storage class name to something usable within your cluster. Minikube accepts 'standard'
      storageClassName: standard
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 2Gi

redis:
  # -- redis.storage --
  # This is the storage spec that the persistent redis uses to maintain state for
  # a running dragonchain. Configure this as needed
  storage:
    spec:
      # Switch storage class name to something usable within your cluster. Minikube accepts 'standard'
      storageClassName: standard
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 1Gi
  # -- redis.image --
  # This is the image that dragonchain uses for a persistent and LRU redis
  image:
    repository: docker.io/redis
    tag: 5.0.5-alpine

redisearch:
  # -- redis.storage --
  # This is the storage spec that the redisearch uses to maintain state for
  # a running dragonchain. Configure this as needed
  storage:
    spec:
      # Switch storage class name to something usable within your cluster. Minikube accepts 'standard'
      storageClassName: standard
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 1Gi
  # -- redis.image --
  # This is the image that dragonchain uses for the redisearch used for indexing
  image:
    repository: docker.io/redislabs/redisearch
    tag: 1.4.16
# For more information on kubernetes storage, view the docs: https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/
# PersistentVolumeClaimSpec API Reference: https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/#persistentvolumeclaimspec-v1-core
